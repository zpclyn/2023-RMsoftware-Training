# 单片机入门

说明：本文档主要将对环境配置、工程建立以及寄存器和库开发进行总述。对于环境配置，大多为重复性工作，将简要概述，安装时请大家参照文档中给出的安装链接逐步安装即可。对于寄存器以及库函数的使用将着重讲述。

## 1. MDK5简介

MDK5是源自于德国KEIL公司，目前最新版本为**MDK v5.37**，该版本使用**uVision5 IDE**集成开发环境，是目前针对 ARM 处理器，尤其是**Cortex M**内核处理器的最佳开发工具。MDK5 由两个部分组成： MDK Core 和 Software Packs。其中，Software Packs 可以独立于工具链进行新芯片支持和中间库的升级。

首先讲讲Software Packs（包安装器），其中分为：

1. Device（芯片支持）
2. CMSIS ARM Cortex（微控制器软件接口标准）
3. Mdidleware （中间库）

### 1.1 CMSIS标准讲解

直接理解编译器的这些内核比较抽象，首先我们先从CMSIS标准入手。大家刚接触单片机时，经常会疑惑，51、32、msp这些单片机都有什么区别，STM32和ARM时什么关系。

首先一点，大家应该对内核与外设进行区分。

单片机由一个IP核和片上外设组成，IP核（内核）就是CPU，片上外设就是：时钟电路、SFR和RAM、ROM、定时/计数器、并行I/O口、串行I/O口、中断系统。IP核跟外设之间由系统总线连接，且是8bit的，速度有限。

对于51

​		我们在学习51的时候，关于内核部分接触的比较少，使用的最多的是片上外设，我们在编程的时候操作的也就是这些外设。

对于32

1. 在系统结构上，STM32和51都属于单片机，都是由内核和片上外设组成。只是STM32使用的Cortex-M3内核比51复杂得多，优秀得多，支持的外设也比51多得多，同时总线宽度也上升到32bit，无论速度、功耗、外设都强于51。
2. 从结构框图上看， STM32比51的外设多得多，51有的串口、定时器、IO口等外设 STM32 都有。STM32还多了很多特色外设：如FSMC、SDIO、SPI、I2C等，这些外设按照速度的不同，分别挂载到AHB、APB2、APB1这三条总线上。

ARM是一个做芯片标准的公司，它负责的是芯片内核的架构设计，而 TI ST 这样的公司，他们并不做标准，他们是芯片公司。因此大家从51到32会发现变化很大，这是由于芯片架构不同。对于8051其采用**MCS-48**系列结构，而STM32采用**Cortex-M3**芯片。对于架构不同的芯片在配置上往往差异很大。

[![cotrx芯片架构](https://raw.githubusercontent.com/Hebut-Smartcar/18th_Training_Part/f8d069c9ed257c11e3964b2e1346126cfa8fea7d/IMAGE/software_image/week3/STM32F1%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88%E6%9C%AC_V3.jpg)](https://raw.githubusercontent.com/Hebut-Smartcar/18th_Training_Part/f8d069c9ed257c11e3964b2e1346126cfa8fea7d/IMAGE/software_image/week3/STM32F1开发指南-库函数版本_V3.jpg))

对于相同的内核，本质上都是一样的。因此ARM公司为了能让不同的芯片公司生产的 **Cortex M3** 芯片能在软件上基本兼容，和芯片生产商共同提出了一套标准CMSIS标准 **Cortex Microcontroller Software Interface Standard** ) 翻译过来是ARM Cortex™ 微控制器软件接口标准。ST 官方库就是根据这套标准设计的。这里我们又要引用参考资料里面的图片来看看基于 **CMSIS** 应用程序基本结构

[![cotrx程序架构](https://raw.githubusercontent.com/Hebut-Smartcar/18th_Training_Part/main/IMAGE/software_image/week3/cotrx%E7%A8%8B%E5%BA%8F%E6%9C%BA%E6%9E%84.png)](https://raw.githubusercontent.com/Hebut-Smartcar/18th_Training_Part/main/IMAGE/software_image/week3/cotrx程序机构.png)

CMSIS分为 3 个基本功能层：

1. 核内外设访问层： ARM 公司提供的访问，定义处理器内部寄存器地址以及功能函数。
2. 中间件访问层 定义访问中间件的通用 API, 也是 ARM 公司提供。
3. 外设访问层：定义硬件寄存器的地址以及外设的访问函数。

[![CMSIS](https://raw.githubusercontent.com/Hebut-Smartcar/18th_Training_Part/main/IMAGE/software_image/week3/cmsi.png)](https://raw.githubusercontent.com/Hebut-Smartcar/18th_Training_Part/main/IMAGE/software_image/week3/cmsi.png)

从图中可以看出，**CMSIS**层在整个系统中是处于中间层，向下负责与内核和各个外设直接打交道，向上提供实时操作系统用户程序调用的函数接口。如果没有 **CMSIS** 标准，那么各个芯片公司就会设计自己喜欢的风格的库函数，而 CMSIS 标准就是要强制规定，芯片生产公司设计的库函数必须按照 **CMSIS** 这套规范来设计。

**简单表述** 一个简单的例子，我们在使用 STM32 芯片的时候首先要进行系统初始化， CMSIS 规范就规定， 系统 初始化函数名字必须为 SystemInit ，所以各个芯片公司写自己的库函数的时候就必须用 SystemInit 对系统进行初始化。CMSIS 还对各个外设驱动文件的文件名字规范化，以及函数名字规范化等等一系列规定。对于库函数中GPIO_ResetBits函数名字也是不能随便定义的，是要遵循 CMSIS 规范的。

### 1.2 KEIL安装以及环境配置

参考week2中的安装。

## 2. 库开发与寄存器开发的关系

很多用户都是从学51单片机开发转而想进一步学习STM32开发，他们习惯了51单片机的寄存器开发方式，突然一个 ST 官方库摆在面前会一头雾水，不知道从何下手。下面我们将通过一个简单的例子来告诉 STM32 固件库到底是什么，和寄存器开发有什么关系？ 其实一句话就可以概括：**固件库就是函数的集合，固件库函数的作用是向下负责与寄存器直接打交道 向上提供用户函数调用的接口（*API* )**。 在51的开发中我们常常的作法是直接操作寄存器，比如要控制某些 IO 口的状态，我们直接操作寄存器：`P0=0x11;`， 而在STM32 的开发中，我们同样可以操作寄存器: `GPIOx-->BRR = 0x0011;` ，这种方法当然可以，但是这种方法的劣势是你需要去掌握每个寄存器的用法，你才能正确使用STM32 ，而对于 STM32 这种级别的 MCU ，数百个寄存器记起来又是谈何容易。于是 ST( 意法半导体）推出了官方固件库，固件库将这些寄存器底层操作都封装起来，提供一整套接口（**API**)供开发者调用，大多数场合下，你不需要去知道操作的是哪个寄存器，你只需要知道调用哪些函数即可。(**回忆下上文中的内容，库函数的标准是由CMSIS定义的规范**)

以库函数中的控制**BRR**寄存器电平控制为例：

```
void GPIO_ResetBits(GPI O_ TypeDef* GPIOx, uint16_t GPIO_Pin)
{
      GPIOx -->BRR = GPIO_Pin;
}
```

这样你就可以调用函数就可以控制电平了。

## 3. STM32官方库包

### 3.1 标准库

首先说明，我们的培训以标准库为主，HAL库请心有余力的同学自行学习。在标准库的学习中，我们将接触大量用户可调用函数，虽然带有代码提示，但仍需对库函数有一定熟悉。本周我们先学习工程的建立方法。

#### 3.1.1 工程的建立

1. 新建文件夹：建立一个存放工程的文件夹（暂时命名为“工程模板”）。

2. 新建工程：打开Keil5，点击菜单栏Project->New Project，选择工程模板文件夹，命名文件名为Project（仅个人习惯），点击保存（PS：可以在文件夹名称处说明工程目的，文件名称不易修改）。选择器件型号，STMicroelectronics->STM32F1 Series->STM32F103->STM32F103C8（以STM32F103C8T6为例），点击OK，关掉弹出页面。

3. 添加文件管理文件夹：打开工程模板文件夹，新建五个文件夹，分别为“Start”、“Library”、“System”、“Hardware”和“User”（仅个人习惯，熟悉后可自行更改）。

4. 添加Start文件夹：打开固件库文件夹，Libraries->CMSIS->CM3->DeviceSupport->ST->STM32F10x->startup->arm（PS：CM3是Cortex-M3的缩写），里面存放着STM32的启动文件，STM32的程序就是从启动文件开始执行的，按照下图标准选择一个启动文件复制到Start文件夹下（以STM32F103C8T6为例，选择startup_stm32f10x_md.s文件）。回到STM32F10x文件夹，将stm32f10x.h（外设寄存器描述文件，存放寄存器名称和地址）、system_stm32f10x.c和system_stm32f10x.h（配置时钟的文件）也复制到Start文件夹。回到CM3，打开CorSupport文件夹，将core_cm3.c和core_cm3.h（内核寄存器描述文件）也复制到Start文件夹。
	![](https://github.com/zpclyn/2023-RMsoftware-Training/blob/main/IMAGE/week3/BE7B2E26BC2157C55AA03EA473233BB1.jpg)

5. 添加Library文件夹：回到Libraries文件夹，STM32F10x_StdPeriph_Driver（STM32标准外设驱动）->src,将所有文件复制到Library文件夹，回到STM32F10x_StdPeriph_Driver文件夹，打开inc文件夹，全部复制到Library文件夹（misc为内核库函数，其他的是内核外的外设库函数）。

6. 添加User文件夹：回到固件库文件夹，打开Project->STM32F10x_StdPeriph_Template，将stm32f10x_conf.h（用来配置库函数头文件的包含关系）、stm32f10x_it.c和stm32f10x_it.h（存放中断函数）复制到User文件夹。

7. 导入文件：在Keil的菜单栏下方找到“三个箱子”的图标（第二行倒数第五个），在Groups一栏，将Source Group 1改为Start（双击修改），在Files一栏，点击Add Files，将Start文件夹的所以文件导入（PS：导入后可用Alt+上下键调整文件位置）。在Groups一栏新建分组，点击上面右侧四个按钮第一个，命名为Library，将Library文件夹的所有文件导入。新建分组User，添加User文件夹所有文件。新建分组System和Hardware。

8. 添加头文件路径：在Keil的菜单栏下方找到“魔术棒”的图标（第二行倒数第六个），在C/C++里找到Define一栏输入USE_STDPERIPH_DRIVER（使#include “stm32f10x_conf.h”语句有效），再找到Include Paths栏，点右侧三个点，新建路径（上面右侧四个按钮第一个），再点击三个点，浏览文件夹，选择“Start”，同理将“Library”、“System”、“Hardware”和“User”的路径也添加进来。

9. 添加main文件：在左侧边栏User分类处右键添加新建项（Add New Item to Group “User”），选择c File，命名为main，在位置一栏后面加上“\User”，否则会添加到工程模板文件夹而不是User文件夹。在main.c里，右键添加头文件（Insert ‘#include file’），选择stm32f10x.h，写一个main标准模板：

	``` c
	#include "stm32f10x.h"                  // Device header
	
	int main(void)
	{
		while(1)
		{
		}
	}
	
	```

	注意文件最后一行必须是空行，否则会警告。

10. 配置调试器，点击“魔术棒”图标，选择Debug，右侧最上边Use一栏，下拉选择ST-Link Debugger，点击Settings，选择Flash Download按钮，选中Reset and Run（下载程序后立刻复位并执行）。

11. 点击Build按钮（F7）编译并建立工程（Keil的菜单栏下方第二行第二个），再点击Download按钮（F8）下载程序（Keil的菜单栏下方第二行第六个），注意只有零错误并接有下载器时才能下载程序。

PS：在Keil的菜单栏下方找到“扳手”的图标（第一行倒数第一个），在Editor可以修改编码格式，我一般比较习惯使用UTF-8。

### 3.2 HAL库

教程将STM32Cube（HAL库）进行创建，对于库函数创建较为复杂，但分别了解每个文件夹的意义将很有助于了解stm的内核。对于HAL库创建，本次使用CubeMX创建，图像化界面将有助于大家理解STM32的配置过程。 学习建议：首先使用CubeMX动手操作，创建工程文件，理解创建时的每一个操作。之后再使用库函数创建工程文件，自行配置相关驱动。

#### 3.2.1 库函数与HAL库的关系

简单的来说，我们要讨论的HAL库是ST公司为了更方便地进行STM32之间的移植而开发的库，通用性很强，在不同的两款STM32芯片之间的移植基本上不需要修改。之前使用的标准库都是基于寄存器的操作。寄存器版本使用较麻烦，每个设置都要去查看芯片datasheet，好处是可以让你熟悉芯片的寄存器配置。库函数是基于寄存器版本进行二次封装后推出的，它的优势就是寄存器版本的劣势，方便了使用，不再需要手动去配置寄存器，使用更方便了。但是它的劣势就是HAL的优势，就是每次修改MCU功能，都需要手动去修改功能，而且自己修改也不能保证正确性，程序代码在不同MCU之间的移植性不强。

#### 3.2.2 使用CubeMX进HAL配置

STM32CubeMX是意法半导体推出的图形化配置工具，通过傻瓜化的操作便能实现相关配置，最终能够生成C语言代码。接下来将分步骤介绍使用STM32CubmeMX及MDK、STM32CubmeMX及TrueStudio进行STM32程序设计。 备注：运行环境搭建请参考“https://blog.csdn.net/sudaroot/article/details/79364484”

##### 3.2.2.1 新建工程模板

使用CubMX配置的一般步骤：

1. 工程初步建立和保存
2. RCC设置
3. 时钟树配置
4. GPIO功能配置
5. 生成工程源码
6. 编写用户代码

接下来将从以上6个步骤分别进行配置；具体配置参考“https://blog.csdn.net/as480133937/article/details/98947162” 这里仅对较为重要的地方进行强调

###### 3.2.2.2 新建工程

选择时注意选择对型号，可以参考开发板的原理图等。

###### 3.2.2.3 RCC设置/时钟树

时钟这个部分很重要，但那个文档讲的不是很详细。简要而言时钟是单片机运行的基础，时钟信号推动单片机内各个部分执行相应的指令。时钟系统就是CPU的脉搏，决定CPU速率，像人的心跳一样，只有有了心跳，人才能做其他的事情，而单片机有了时钟，才能够运行执行指令，才能够做其他的处理 (点灯，串口，ADC)，时钟的重要性不言而喻。
在配置时首先进入RCC配置栏，选择**HSE（高速时钟）** 的值为 **Crystal/Ceramic Resonator（使用晶振 /陶瓷振荡器）** 这里还需要说明一下，值**Bypass Clock Source** 的意思是旁路时钟源，也就是不使用使用晶振/陶瓷振荡器，直接通过外部提供一个可靠的4-26MHz时钟作为HSE。**(再说明一下，给出的参考使用的是内部时钟，其中由于内部时钟是由STM32内部振荡器提供的时钟源，其稳定性不如外部接入的晶体振荡器，但都可以作为时钟源，具体使用应参考使用的开发板的硬件设计)**

时钟树配置:
在使用 STM32CubeMX配置时钟树之前，大家需要充分理解 STM32时钟系统，**配置时钟树就是配置每一个端口或外设的运行频率**。
具体参考这里“https://blog.csdn.net/as480133937/article/details/98845509”，在这里通过CubeMX可以快速配置;
点击 Clock Configuration选项卡即可进入时钟系统配置栏，如下图
[![时钟树](https://github.com/Hebut-Smartcar/18th_Training_Part/raw/main/software/week3/document/12)](https://github.com/Hebut-Smartcar/18th_Training_Part/blob/main/software/week3/document/12) 
我们把系统时钟配置分为6个步骤 ，分别用标号1-6表示，详细过程为：

1. 时钟源参数设置： HSE或者 HSI配置。
2. 时钟源选择：HSE还是HSI。
3. PLL分频系数M配置。
4. 主PLL倍频系数N配置倍频系数N。
5. 主PLL分频系数P配置。
6. 系统时钟时钟源选择：PLL,HSI还是HSE。

[![时钟树2](https://raw.githubusercontent.com/Hebut-Smartcar/18th_Training_Part/main/IMAGE/software_image/week3/%E6%97%B6%E9%92%9F%E6%A0%912.jpg)](https://raw.githubusercontent.com/Hebut-Smartcar/18th_Training_Part/main/IMAGE/software_image/week3/时钟树2.jpg)

以上功能大家初学时可能理解很困难，可以先尝试做一遍，再之后的学习中慢慢理解。

###### 3.2.2.4 GPIO功能配置

只需要点击对应的GPIO进行配置即可。（**强调：这里做的仅仅是配置（和51单片机有点区别，51 的配置文件在头文件中大家可能没有注意到），要具体操作时例如点亮灯，还需要在程序中编写函数**）

###### 3.2.2.5 生成工程源码

**强调：路径不能有中文！！！！存放的文件夹都不能有；** 记得勾选Generate Penpheral intialization as a pair 'c/h' files per Penpheral 这样使你得main.c文件比较简洁，便于编写。

###### 3.2.2.6 编写用户代码

```
    HAL_Delay(500);//HAL中延迟函数，单位ms
    HAL_GPIO_TogglePin(GPIOE, GPIO_PIN_15);//翻转GPIO相关引脚需要在3.23中配置，否则不能使用
```

小技巧，可以通过右键函数，点击go to defintion查看（如果无法查看请进行编译build）
